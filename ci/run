#!/usr/bin/env bash
#
# Script run by buildkite that builds and tests the project.
#
# See
# * https://buildkite.com/docs/pipelines/managing-log-output
# * https://buildkite.com/docs/pipelines/writing-build-scripts

set -euo pipefail

if [[ ${CI_VERBOSE:-} =~ ^1|true$ ]]; then
  set -x
fi

TIMEFORMAT='elapsed time: %R (user: %U, system: %S)'

declare -r target_cache="/cache/target"

export CARGO_HOME=/cache/cargo
# Incremental builds use timestamps of local code. Since we always
# check it out fresh we can never use incremental builds.
export CARGO_BUILD_INCREMENTAL=false

export RUSTC_WRAPPER=sccache
export SCCACHE_DIR=/cache/sccache
# Most of the caching is done through caching ./target
export SCCACHE_CACHE_SIZE="1G"

echo "--- Prepare cache"
free_cache_space_kb=$(df --output=avail /cache | sed -n 2p)
min_free_cache_kb=$(( 800 * 1024 ))
echo "$(( free_cache_space_kb / 1024 )) MiB free space on /cache"
if [[ $free_cache_space_kb -le $min_free_cache_kb ]]; then
  echo "Reseting cache with rm -rf /cache/*"
  du -sh /cache/*
  rm -rf /cache/*
fi
mkdir -p "$target_cache"
ln -s "$target_cache" ./target

echo "--- scripts/check-license-headers"
time ./scripts/check-license-headers

echo "--- cargo fmt"
time cargo fmt --all -- --check

export BUILD_DUMMY_WASM_BINARY=0
export RUSTFLAGS="-D warnings"

echo "--- cargo clippy"
cargo clippy --workspace --all-targets --release -- -D clippy::all
echo "--- cargo clippy (for wasm32 target)"
cargo clippy --manifest-path runtime/Cargo.toml --no-default-features --target wasm32-unknown-unknown -- -D clippy::all
echo "--- cargo build"
cargo build --workspace --all-targets --release

echo "--- cargo test"
echo "Starting radicle-registry-node"
RUST_LOG=error ./target/release/radicle-registry-node \
  --dev \
  --base-path /tmp/radicle-registry \
  &
registry_node_pid=$!
# We build tests in release mode so that we can reuse the artifacts
# from 'cargo build'
cargo test --workspace --release --color=always
kill "$registry_node_pid"

echo "--- Copy artifacts"
mkdir artifacts
cp -a target/release/radicle-registry-node artifacts
cp -a target/release/radicle-registry-node ci/node-image

echo "--- Cleanup cache"
# Remove all executables that need to be rebuild.
find ./target -maxdepth 2 -executable -type f -exec rm {} \;
# Remove artifats from local code
rm -r target/release/deps/radicle* target/release/build/radicle*
echo "Size of $target_cache is $(du -sh "$target_cache" | cut -f 1)"

# Upload the node binary to bintray.
#
# For master builds we use the `radicle-registry-node` package and the
# date and build number as the version.
#
# For branch builds we use the `radicle-registry-dev` package and the
# commit hash as the version
function upload_to_bintray () {
  local -r api_url="https://bintray.com/api/v1"
  local -r subject="oscoin"
  local -r repo="radicle-registry-files"

  if [[ "$BUILDKITE_BRANCH" == "master" ]]; then
    local -r package="radicle-registry"
    local -r version="d$(date +%Y-%m-%d).$BUILDKITE_BUILD_NUMBER"
  else
    local -r package="radicle-registry-dev"
    local -r version="git-$BUILDKITE_COMMIT"
  fi

  local -r target_triple="x86_64-linux-gnu"
  local -r remote_file="by-commit/$BUILDKITE_COMMIT/$target_triple/radicle-registry-node"
  local -r local_file="./artifacts/radicle-registry-node"

  local file_checksum
  file_checksum="$(sha256sum "$local_file" | cut -f1 -d ' ')"

  echo "Uploading files for $package $version"
  curl \
    --fail --show-error \
    -X PUT \
    --basic --user "$BINTRAY_API_KEY" \
    -H "X-Bintray-Package: $package" \
    -H "X-Bintray-Version: $version" \
    -H "X-Bintray-Override: 1" \
    -H "X-Checksum-Sha2: $file_checksum" \
    "$api_url/content/$subject/$repo/$remote_file" \
    --data-binary @$local_file \
    # We ignore failures until the issue with the storage limit is resolved
    || true
  # Response from curl does not end with new line
  echo

  local -r download_path="https://dl.bintray.com/$subject/$repo/$remote_file"
  echo "Node binary available from $download_path"

  echo "Publishing $package $version"
  curl \
    --fail --show-error \
    -X POST \
    --basic --user "$BINTRAY_API_KEY" \
    -H "content-type: application/json" \
    "$api_url/content/$subject/$repo/$package/$version/publish" \
    --data-binary '{ "publish_wait_for_secs": -1 }' \
    # We ignore failures until the issue with the storage limit is resolved
    || true
  # Response from curl does not end with new line
  echo

  echo "Adding file to download list"
  # We ignore errors. This is not crucial for the build to pass
  curl \
    -X PUT \
    --basic --user "$BINTRAY_API_KEY" \
    -H "content-type: application/json" \
    "$api_url/file_metadata/$subject/$repo/$remote_file" \
    --data-binary '{ "list_in_downloads": true }' \
    # We ignore failures until the issue with the storage limit is resolved
    || true
  # Response from curl does not end with new line
  echo
}

if [[ -n "${BINTRAY_API_KEY:-}" ]]; then
  echo "--- Upload bintray artifacts"
  upload_to_bintray
fi
